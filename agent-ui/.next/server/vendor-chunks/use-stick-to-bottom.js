"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-stick-to-bottom";
exports.ids = ["vendor-chunks/use-stick-to-bottom"];
exports.modules = {

/***/ "(ssr)/./node_modules/use-stick-to-bottom/dist/StickToBottom.js":
/*!****************************************************************!*\
  !*** ./node_modules/use-stick-to-bottom/dist/StickToBottom.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StickToBottom: () => (/* binding */ StickToBottom),\n/* harmony export */   useStickToBottomContext: () => (/* binding */ useStickToBottomContext)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _useStickToBottom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useStickToBottom.js */ \"(ssr)/./node_modules/use-stick-to-bottom/dist/useStickToBottom.js\");\n\n/*!---------------------------------------------------------------------------------------------\n *  Copyright (c) StackBlitz. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nconst StickToBottomContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\nfunction StickToBottom({ instance, children, resize, initial, mass, damping, stiffness, targetScrollTop: currentTargetScrollTop, contextRef, ...props }) {\n    const customTargetScrollTop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const targetScrollTop = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((target, elements) => {\n        const get = context?.targetScrollTop ?? currentTargetScrollTop;\n        return get?.(target, elements) ?? target;\n    }, [currentTargetScrollTop]);\n    const defaultInstance = (0,_useStickToBottom_js__WEBPACK_IMPORTED_MODULE_2__.useStickToBottom)({\n        mass,\n        damping,\n        stiffness,\n        resize,\n        initial,\n        targetScrollTop,\n    });\n    const { scrollRef, contentRef, scrollToBottom, stopScroll, isAtBottom, escapedFromLock, state, } = instance ?? defaultInstance;\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n        scrollToBottom,\n        stopScroll,\n        scrollRef,\n        isAtBottom,\n        escapedFromLock,\n        contentRef,\n        state,\n        get targetScrollTop() {\n            return customTargetScrollTop.current;\n        },\n        set targetScrollTop(targetScrollTop) {\n            customTargetScrollTop.current = targetScrollTop;\n        },\n    }), [\n        scrollToBottom,\n        isAtBottom,\n        contentRef,\n        scrollRef,\n        stopScroll,\n        escapedFromLock,\n        state,\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(contextRef, () => context, [context]);\n    useIsomorphicLayoutEffect(() => {\n        if (!scrollRef.current) {\n            return;\n        }\n        if (getComputedStyle(scrollRef.current).overflow === \"visible\") {\n            scrollRef.current.style.overflow = \"auto\";\n        }\n    }, []);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StickToBottomContext.Provider, { value: context, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ...props, children: typeof children === \"function\" ? children(context) : children }) }));\n}\n(function (StickToBottom) {\n    function Content({ children, ...props }) {\n        const context = useStickToBottomContext();\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: context.scrollRef, style: {\n                height: \"100%\",\n                width: \"100%\",\n            }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ...props, ref: context.contentRef, children: typeof children === \"function\" ? children(context) : children }) }));\n    }\n    StickToBottom.Content = Content;\n})(StickToBottom || (StickToBottom = {}));\n/**\n * Use this hook inside a <StickToBottom> component to gain access to whether the component is at the bottom of the scrollable area.\n */\nfunction useStickToBottomContext() {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StickToBottomContext);\n    if (!context) {\n        throw new Error(\"use-stick-to-bottom component context must be used within a StickToBottom component\");\n    }\n    return context;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLXN0aWNrLXRvLWJvdHRvbS9kaXN0L1N0aWNrVG9Cb3R0b20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDK0I7QUFDc0Y7QUFDM0Q7QUFDMUQsNkJBQTZCLG9EQUFhO0FBQzFDLGtFQUFrRSxrREFBZSxHQUFHLDRDQUFTO0FBQ3RGLHlCQUF5Qiw4SEFBOEg7QUFDOUosa0NBQWtDLDZDQUFNO0FBQ3hDLDRCQUE0Qiw4Q0FBaUI7QUFDN0M7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsc0VBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHlGQUF5RjtBQUNyRyxvQkFBb0IsOENBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBEQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHNEQUFJLGtDQUFrQywwQkFBMEIsc0RBQUksVUFBVSxtRkFBbUYsR0FBRztBQUNoTDtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBLGdCQUFnQixzREFBSSxVQUFVO0FBQzlCO0FBQ0E7QUFDQSxhQUFhLFlBQVksc0RBQUksVUFBVSw0R0FBNEcsR0FBRztBQUN0SjtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsaURBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2dhYnJpZWxtZXp6YWxpcmEvRG9jdW1lbnRzL0ZhY3VsZGFkZS9QMi9DSXRpL1BUQS9QVEEtY2llbmNpYS1kZS1kYWRvc19SYWZhZWwvYWdlbnQtdWkvbm9kZV9tb2R1bGVzL3VzZS1zdGljay10by1ib3R0b20vZGlzdC9TdGlja1RvQm90dG9tLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG4vKiEtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIFN0YWNrQmxpdHouIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZUxheW91dEVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RpY2tUb0JvdHRvbSwgfSBmcm9tIFwiLi91c2VTdGlja1RvQm90dG9tLmpzXCI7XG5jb25zdCBTdGlja1RvQm90dG9tQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcbmV4cG9ydCBmdW5jdGlvbiBTdGlja1RvQm90dG9tKHsgaW5zdGFuY2UsIGNoaWxkcmVuLCByZXNpemUsIGluaXRpYWwsIG1hc3MsIGRhbXBpbmcsIHN0aWZmbmVzcywgdGFyZ2V0U2Nyb2xsVG9wOiBjdXJyZW50VGFyZ2V0U2Nyb2xsVG9wLCBjb250ZXh0UmVmLCAuLi5wcm9wcyB9KSB7XG4gICAgY29uc3QgY3VzdG9tVGFyZ2V0U2Nyb2xsVG9wID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHRhcmdldFNjcm9sbFRvcCA9IFJlYWN0LnVzZUNhbGxiYWNrKCh0YXJnZXQsIGVsZW1lbnRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGdldCA9IGNvbnRleHQ/LnRhcmdldFNjcm9sbFRvcCA/PyBjdXJyZW50VGFyZ2V0U2Nyb2xsVG9wO1xuICAgICAgICByZXR1cm4gZ2V0Py4odGFyZ2V0LCBlbGVtZW50cykgPz8gdGFyZ2V0O1xuICAgIH0sIFtjdXJyZW50VGFyZ2V0U2Nyb2xsVG9wXSk7XG4gICAgY29uc3QgZGVmYXVsdEluc3RhbmNlID0gdXNlU3RpY2tUb0JvdHRvbSh7XG4gICAgICAgIG1hc3MsXG4gICAgICAgIGRhbXBpbmcsXG4gICAgICAgIHN0aWZmbmVzcyxcbiAgICAgICAgcmVzaXplLFxuICAgICAgICBpbml0aWFsLFxuICAgICAgICB0YXJnZXRTY3JvbGxUb3AsXG4gICAgfSk7XG4gICAgY29uc3QgeyBzY3JvbGxSZWYsIGNvbnRlbnRSZWYsIHNjcm9sbFRvQm90dG9tLCBzdG9wU2Nyb2xsLCBpc0F0Qm90dG9tLCBlc2NhcGVkRnJvbUxvY2ssIHN0YXRlLCB9ID0gaW5zdGFuY2UgPz8gZGVmYXVsdEluc3RhbmNlO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIHNjcm9sbFRvQm90dG9tLFxuICAgICAgICBzdG9wU2Nyb2xsLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIGlzQXRCb3R0b20sXG4gICAgICAgIGVzY2FwZWRGcm9tTG9jayxcbiAgICAgICAgY29udGVudFJlZixcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGdldCB0YXJnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tVGFyZ2V0U2Nyb2xsVG9wLmN1cnJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB0YXJnZXRTY3JvbGxUb3AodGFyZ2V0U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICBjdXN0b21UYXJnZXRTY3JvbGxUb3AuY3VycmVudCA9IHRhcmdldFNjcm9sbFRvcDtcbiAgICAgICAgfSxcbiAgICB9KSwgW1xuICAgICAgICBzY3JvbGxUb0JvdHRvbSxcbiAgICAgICAgaXNBdEJvdHRvbSxcbiAgICAgICAgY29udGVudFJlZixcbiAgICAgICAgc2Nyb2xsUmVmLFxuICAgICAgICBzdG9wU2Nyb2xsLFxuICAgICAgICBlc2NhcGVkRnJvbUxvY2ssXG4gICAgICAgIHN0YXRlLFxuICAgIF0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUoY29udGV4dFJlZiwgKCkgPT4gY29udGV4dCwgW2NvbnRleHRdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFzY3JvbGxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHNjcm9sbFJlZi5jdXJyZW50KS5vdmVyZmxvdyA9PT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgICAgIHNjcm9sbFJlZi5jdXJyZW50LnN0eWxlLm92ZXJmbG93ID0gXCJhdXRvXCI7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChfanN4KFN0aWNrVG9Cb3R0b21Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogX2pzeChcImRpdlwiLCB7IC4uLnByb3BzLCBjaGlsZHJlbjogdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihjb250ZXh0KSA6IGNoaWxkcmVuIH0pIH0pKTtcbn1cbihmdW5jdGlvbiAoU3RpY2tUb0JvdHRvbSkge1xuICAgIGZ1bmN0aW9uIENvbnRlbnQoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfSkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdXNlU3RpY2tUb0JvdHRvbUNvbnRleHQoKTtcbiAgICAgICAgcmV0dXJuIChfanN4KFwiZGl2XCIsIHsgcmVmOiBjb250ZXh0LnNjcm9sbFJlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBfanN4KFwiZGl2XCIsIHsgLi4ucHJvcHMsIHJlZjogY29udGV4dC5jb250ZW50UmVmLCBjaGlsZHJlbjogdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihjb250ZXh0KSA6IGNoaWxkcmVuIH0pIH0pKTtcbiAgICB9XG4gICAgU3RpY2tUb0JvdHRvbS5Db250ZW50ID0gQ29udGVudDtcbn0pKFN0aWNrVG9Cb3R0b20gfHwgKFN0aWNrVG9Cb3R0b20gPSB7fSkpO1xuLyoqXG4gKiBVc2UgdGhpcyBob29rIGluc2lkZSBhIDxTdGlja1RvQm90dG9tPiBjb21wb25lbnQgdG8gZ2FpbiBhY2Nlc3MgdG8gd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGF0IHRoZSBib3R0b20gb2YgdGhlIHNjcm9sbGFibGUgYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0aWNrVG9Cb3R0b21Db250ZXh0KCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFN0aWNrVG9Cb3R0b21Db250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXNlLXN0aWNrLXRvLWJvdHRvbSBjb21wb25lbnQgY29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgU3RpY2tUb0JvdHRvbSBjb21wb25lbnRcIik7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-stick-to-bottom/dist/StickToBottom.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-stick-to-bottom/dist/useStickToBottom.js":
/*!*******************************************************************!*\
  !*** ./node_modules/use-stick-to-bottom/dist/useStickToBottom.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStickToBottom: () => (/* binding */ useStickToBottom)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/*!---------------------------------------------------------------------------------------------\n *  Copyright (c) StackBlitz. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nconst DEFAULT_SPRING_ANIMATION = {\n    /**\n     * A value from 0 to 1, on how much to damp the animation.\n     * 0 means no damping, 1 means full damping.\n     *\n     * @default 0.7\n     */\n    damping: 0.7,\n    /**\n     * The stiffness of how fast/slow the animation gets up to speed.\n     *\n     * @default 0.05\n     */\n    stiffness: 0.05,\n    /**\n     * The inertial mass associated with the animation.\n     * Higher numbers make the animation slower.\n     *\n     * @default 1.25\n     */\n    mass: 1.25,\n};\nconst STICK_TO_BOTTOM_OFFSET_PX = 70;\nconst SIXTY_FPS_INTERVAL_MS = 1000 / 60;\nconst RETAIN_ANIMATION_DURATION_MS = 350;\nlet mouseDown = false;\nglobalThis.document?.addEventListener(\"mousedown\", () => {\n    mouseDown = true;\n});\nglobalThis.document?.addEventListener(\"mouseup\", () => {\n    mouseDown = false;\n});\nglobalThis.document?.addEventListener(\"click\", () => {\n    mouseDown = false;\n});\nconst useStickToBottom = (options = {}) => {\n    const [escapedFromLock, updateEscapedFromLock] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isAtBottom, updateIsAtBottom] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(options.initial !== false);\n    const [isNearBottom, setIsNearBottom] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const optionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    optionsRef.current = options;\n    const isSelecting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (!mouseDown) {\n            return false;\n        }\n        const selection = window.getSelection();\n        if (!selection || !selection.rangeCount) {\n            return false;\n        }\n        const range = selection.getRangeAt(0);\n        return (range.commonAncestorContainer.contains(scrollRef.current) ||\n            scrollRef.current?.contains(range.commonAncestorContainer));\n    }, []);\n    const setIsAtBottom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((isAtBottom) => {\n        state.isAtBottom = isAtBottom;\n        updateIsAtBottom(isAtBottom);\n    }, []);\n    const setEscapedFromLock = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((escapedFromLock) => {\n        state.escapedFromLock = escapedFromLock;\n        updateEscapedFromLock(escapedFromLock);\n    }, []);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: not needed\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        let lastCalculation;\n        return {\n            escapedFromLock,\n            isAtBottom,\n            resizeDifference: 0,\n            accumulated: 0,\n            velocity: 0,\n            listeners: new Set(),\n            get scrollTop() {\n                return scrollRef.current?.scrollTop ?? 0;\n            },\n            set scrollTop(scrollTop) {\n                if (scrollRef.current) {\n                    scrollRef.current.scrollTop = scrollTop;\n                    state.ignoreScrollToTop = scrollRef.current.scrollTop;\n                }\n            },\n            get targetScrollTop() {\n                if (!scrollRef.current || !contentRef.current) {\n                    return 0;\n                }\n                return (scrollRef.current.scrollHeight - 1 - scrollRef.current.clientHeight);\n            },\n            get calculatedTargetScrollTop() {\n                if (!scrollRef.current || !contentRef.current) {\n                    return 0;\n                }\n                const { targetScrollTop } = this;\n                if (!options.targetScrollTop) {\n                    return targetScrollTop;\n                }\n                if (lastCalculation?.targetScrollTop === targetScrollTop) {\n                    return lastCalculation.calculatedScrollTop;\n                }\n                const calculatedScrollTop = Math.max(Math.min(options.targetScrollTop(targetScrollTop, {\n                    scrollElement: scrollRef.current,\n                    contentElement: contentRef.current,\n                }), targetScrollTop), 0);\n                lastCalculation = { targetScrollTop, calculatedScrollTop };\n                requestAnimationFrame(() => {\n                    lastCalculation = undefined;\n                });\n                return calculatedScrollTop;\n            },\n            get scrollDifference() {\n                return this.calculatedTargetScrollTop - this.scrollTop;\n            },\n            get isNearBottom() {\n                return this.scrollDifference <= STICK_TO_BOTTOM_OFFSET_PX;\n            },\n        };\n    }, []);\n    const scrollToBottom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((scrollOptions = {}) => {\n        if (typeof scrollOptions === \"string\") {\n            scrollOptions = { animation: scrollOptions };\n        }\n        if (!scrollOptions.preserveScrollPosition) {\n            setIsAtBottom(true);\n        }\n        const waitElapsed = Date.now() + (Number(scrollOptions.wait) || 0);\n        const behavior = mergeAnimations(optionsRef.current, scrollOptions.animation);\n        const { ignoreEscapes = false } = scrollOptions;\n        let durationElapsed;\n        let startTarget = state.calculatedTargetScrollTop;\n        if (scrollOptions.duration instanceof Promise) {\n            scrollOptions.duration.finally(() => {\n                durationElapsed = Date.now();\n            });\n        }\n        else {\n            durationElapsed = waitElapsed + (scrollOptions.duration ?? 0);\n        }\n        const next = async () => {\n            const promise = new Promise(requestAnimationFrame).then(() => {\n                if (!state.isAtBottom) {\n                    state.animation = undefined;\n                    return false;\n                }\n                const { scrollTop } = state;\n                const tick = performance.now();\n                const tickDelta = (tick - (state.lastTick ?? tick)) / SIXTY_FPS_INTERVAL_MS;\n                state.animation || (state.animation = { behavior, promise, ignoreEscapes });\n                if (state.animation.behavior === behavior) {\n                    state.lastTick = tick;\n                }\n                if (isSelecting()) {\n                    return next();\n                }\n                if (waitElapsed > Date.now()) {\n                    return next();\n                }\n                if (scrollTop < Math.min(startTarget, state.calculatedTargetScrollTop)) {\n                    if (state.animation?.behavior === behavior) {\n                        if (behavior === \"instant\") {\n                            state.scrollTop = state.calculatedTargetScrollTop;\n                            return next();\n                        }\n                        state.velocity =\n                            (behavior.damping * state.velocity +\n                                behavior.stiffness * state.scrollDifference) /\n                                behavior.mass;\n                        state.accumulated += state.velocity * tickDelta;\n                        state.scrollTop += state.accumulated;\n                        if (state.scrollTop !== scrollTop) {\n                            state.accumulated = 0;\n                        }\n                    }\n                    return next();\n                }\n                if (durationElapsed > Date.now()) {\n                    startTarget = state.calculatedTargetScrollTop;\n                    return next();\n                }\n                state.animation = undefined;\n                /**\n                 * If we're still below the target, then queue\n                 * up another scroll to the bottom with the last\n                 * requested animatino.\n                 */\n                if (state.scrollTop < state.calculatedTargetScrollTop) {\n                    return scrollToBottom({\n                        animation: mergeAnimations(optionsRef.current, optionsRef.current.resize),\n                        ignoreEscapes,\n                        duration: Math.max(0, durationElapsed - Date.now()) || undefined,\n                    });\n                }\n                return state.isAtBottom;\n            });\n            return promise.then((isAtBottom) => {\n                requestAnimationFrame(() => {\n                    if (!state.animation) {\n                        state.lastTick = undefined;\n                        state.velocity = 0;\n                    }\n                });\n                return isAtBottom;\n            });\n        };\n        if (scrollOptions.wait !== true) {\n            state.animation = undefined;\n        }\n        if (state.animation?.behavior === behavior) {\n            return state.animation.promise;\n        }\n        return next();\n    }, [setIsAtBottom, isSelecting, state]);\n    const stopScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        setEscapedFromLock(true);\n        setIsAtBottom(false);\n    }, [setEscapedFromLock, setIsAtBottom]);\n    const handleScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ target }) => {\n        if (target !== scrollRef.current) {\n            return;\n        }\n        const { scrollTop, ignoreScrollToTop } = state;\n        let { lastScrollTop = scrollTop } = state;\n        state.lastScrollTop = scrollTop;\n        state.ignoreScrollToTop = undefined;\n        if (ignoreScrollToTop && ignoreScrollToTop > scrollTop) {\n            /**\n             * When the user scrolls up while the animation plays, the `scrollTop` may\n             * not come in separate events; if this happens, to make sure `isScrollingUp`\n             * is correct, set the lastScrollTop to the ignored event.\n             */\n            lastScrollTop = ignoreScrollToTop;\n        }\n        setIsNearBottom(state.isNearBottom);\n        /**\n         * Scroll events may come before a ResizeObserver event,\n         * so in order to ignore resize events correctly we use a\n         * timeout.\n         *\n         * @see https://github.com/WICG/resize-observer/issues/25#issuecomment-248757228\n         */\n        setTimeout(() => {\n            /**\n             * When theres a resize difference ignore the resize event.\n             */\n            if (state.resizeDifference || scrollTop === ignoreScrollToTop) {\n                return;\n            }\n            if (isSelecting()) {\n                setEscapedFromLock(true);\n                setIsAtBottom(false);\n                return;\n            }\n            const isScrollingDown = scrollTop > lastScrollTop;\n            const isScrollingUp = scrollTop < lastScrollTop;\n            if (state.animation?.ignoreEscapes) {\n                state.scrollTop = lastScrollTop;\n                return;\n            }\n            if (isScrollingUp) {\n                setEscapedFromLock(true);\n                setIsAtBottom(false);\n            }\n            if (isScrollingDown) {\n                setEscapedFromLock(false);\n            }\n            if (!state.escapedFromLock && state.isNearBottom) {\n                setIsAtBottom(true);\n            }\n        }, 1);\n    }, [setEscapedFromLock, setIsAtBottom, isSelecting, state]);\n    const handleWheel = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ target, deltaY }) => {\n        let element = target;\n        while (![\"scroll\", \"auto\"].includes(getComputedStyle(element).overflow)) {\n            if (!element.parentElement) {\n                return;\n            }\n            element = element.parentElement;\n        }\n        /**\n         * The browser may cancel the scrolling from the mouse wheel\n         * if we update it from the animation in meantime.\n         * To prevent this, always escape when the wheel is scrolled up.\n         */\n        if (element === scrollRef.current &&\n            deltaY < 0 &&\n            scrollRef.current.scrollHeight > scrollRef.current.clientHeight &&\n            !state.animation?.ignoreEscapes) {\n            setEscapedFromLock(true);\n            setIsAtBottom(false);\n        }\n    }, [setEscapedFromLock, setIsAtBottom, state]);\n    const scrollRef = useRefCallback((scroll) => {\n        scrollRef.current?.removeEventListener(\"scroll\", handleScroll);\n        scrollRef.current?.removeEventListener(\"wheel\", handleWheel);\n        scroll?.addEventListener(\"scroll\", handleScroll, { passive: true });\n        scroll?.addEventListener(\"wheel\", handleWheel, { passive: true });\n    }, []);\n    const contentRef = useRefCallback((content) => {\n        state.resizeObserver?.disconnect();\n        if (!content) {\n            return;\n        }\n        let previousHeight;\n        state.resizeObserver = new ResizeObserver(([entry]) => {\n            const { height } = entry.contentRect;\n            const difference = height - (previousHeight ?? height);\n            state.resizeDifference = difference;\n            /**\n             * Sometimes the browser can overscroll past the target,\n             * so check for this and adjust appropriately.\n             */\n            if (state.scrollTop > state.targetScrollTop) {\n                state.scrollTop = state.targetScrollTop;\n            }\n            setIsNearBottom(state.isNearBottom);\n            if (difference >= 0) {\n                /**\n                 * If it's a positive resize, scroll to the bottom when\n                 * we're already at the bottom.\n                 */\n                const animation = mergeAnimations(optionsRef.current, previousHeight\n                    ? optionsRef.current.resize\n                    : optionsRef.current.initial);\n                scrollToBottom({\n                    animation,\n                    wait: true,\n                    preserveScrollPosition: true,\n                    duration: animation === \"instant\" ? undefined : RETAIN_ANIMATION_DURATION_MS,\n                });\n            }\n            else {\n                /**\n                 * Else if it's a negative resize, check if we're near the bottom\n                 * if we are want to un-escape from the lock, because the resize\n                 * could have caused the container to be at the bottom.\n                 */\n                if (state.isNearBottom) {\n                    setEscapedFromLock(false);\n                    setIsAtBottom(true);\n                }\n            }\n            previousHeight = height;\n            /**\n             * Reset the resize difference after the scroll event\n             * has fired. Requires a rAF to wait for the scroll event,\n             * and a setTimeout to wait for the other timeout we have in\n             * resizeObserver in case the scroll event happens after the\n             * resize event.\n             */\n            requestAnimationFrame(() => {\n                setTimeout(() => {\n                    if (state.resizeDifference === difference) {\n                        state.resizeDifference = 0;\n                    }\n                }, 1);\n            });\n        });\n        state.resizeObserver?.observe(content);\n    }, []);\n    return {\n        contentRef,\n        scrollRef,\n        scrollToBottom,\n        stopScroll,\n        isAtBottom: isAtBottom || isNearBottom,\n        isNearBottom,\n        escapedFromLock,\n        state,\n    };\n};\nfunction useRefCallback(callback, deps) {\n    // biome-ignore lint/correctness/useExhaustiveDependencies: not needed\n    const result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((ref) => {\n        result.current = ref;\n        return callback(ref);\n    }, deps);\n    return result;\n}\nconst animationCache = new Map();\nfunction mergeAnimations(...animations) {\n    const result = { ...DEFAULT_SPRING_ANIMATION };\n    let instant = false;\n    for (const animation of animations) {\n        if (animation === \"instant\") {\n            instant = true;\n            continue;\n        }\n        if (typeof animation !== \"object\") {\n            continue;\n        }\n        instant = false;\n        result.damping = animation.damping ?? result.damping;\n        result.stiffness = animation.stiffness ?? result.stiffness;\n        result.mass = animation.mass ?? result.mass;\n    }\n    const key = JSON.stringify(result);\n    if (!animationCache.has(key)) {\n        animationCache.set(key, Object.freeze(result));\n    }\n    return instant ? \"instant\" : animationCache.get(key);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLXN0aWNrLXRvLWJvdHRvbS9kaXN0L3VzZVN0aWNrVG9Cb3R0b20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ00sc0NBQXNDO0FBQzdDLHFEQUFxRCwrQ0FBUTtBQUM3RCwyQ0FBMkMsK0NBQVE7QUFDbkQsNENBQTRDLCtDQUFRO0FBQ3BELHVCQUF1Qiw2Q0FBTTtBQUM3QjtBQUNBLHdCQUF3QixrREFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQkFBMEIsa0RBQVc7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0Isa0RBQVc7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQiw4Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLGtEQUFXLG9CQUFvQjtBQUMxRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0Esd0RBQXdELGtDQUFrQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsa0RBQVc7QUFDbEM7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUIsa0RBQVcsSUFBSSxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsd0JBQXdCLGtEQUFXLElBQUksZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxlQUFlO0FBQzFFLHlEQUF5RCxlQUFlO0FBQ3hFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9nYWJyaWVsbWV6emFsaXJhL0RvY3VtZW50cy9GYWN1bGRhZGUvUDIvQ0l0aS9QVEEvUFRBLWNpZW5jaWEtZGUtZGFkb3NfUmFmYWVsL2FnZW50LXVpL25vZGVfbW9kdWxlcy91c2Utc3RpY2stdG8tYm90dG9tL2Rpc3QvdXNlU3RpY2tUb0JvdHRvbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIFN0YWNrQmxpdHouIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUsIH0gZnJvbSBcInJlYWN0XCI7XG5jb25zdCBERUZBVUxUX1NQUklOR19BTklNQVRJT04gPSB7XG4gICAgLyoqXG4gICAgICogQSB2YWx1ZSBmcm9tIDAgdG8gMSwgb24gaG93IG11Y2ggdG8gZGFtcCB0aGUgYW5pbWF0aW9uLlxuICAgICAqIDAgbWVhbnMgbm8gZGFtcGluZywgMSBtZWFucyBmdWxsIGRhbXBpbmcuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAwLjdcbiAgICAgKi9cbiAgICBkYW1waW5nOiAwLjcsXG4gICAgLyoqXG4gICAgICogVGhlIHN0aWZmbmVzcyBvZiBob3cgZmFzdC9zbG93IHRoZSBhbmltYXRpb24gZ2V0cyB1cCB0byBzcGVlZC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IDAuMDVcbiAgICAgKi9cbiAgICBzdGlmZm5lc3M6IDAuMDUsXG4gICAgLyoqXG4gICAgICogVGhlIGluZXJ0aWFsIG1hc3MgYXNzb2NpYXRlZCB3aXRoIHRoZSBhbmltYXRpb24uXG4gICAgICogSGlnaGVyIG51bWJlcnMgbWFrZSB0aGUgYW5pbWF0aW9uIHNsb3dlci5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IDEuMjVcbiAgICAgKi9cbiAgICBtYXNzOiAxLjI1LFxufTtcbmNvbnN0IFNUSUNLX1RPX0JPVFRPTV9PRkZTRVRfUFggPSA3MDtcbmNvbnN0IFNJWFRZX0ZQU19JTlRFUlZBTF9NUyA9IDEwMDAgLyA2MDtcbmNvbnN0IFJFVEFJTl9BTklNQVRJT05fRFVSQVRJT05fTVMgPSAzNTA7XG5sZXQgbW91c2VEb3duID0gZmFsc2U7XG5nbG9iYWxUaGlzLmRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsICgpID0+IHtcbiAgICBtb3VzZURvd24gPSB0cnVlO1xufSk7XG5nbG9iYWxUaGlzLmRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCAoKSA9PiB7XG4gICAgbW91c2VEb3duID0gZmFsc2U7XG59KTtcbmdsb2JhbFRoaXMuZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgbW91c2VEb3duID0gZmFsc2U7XG59KTtcbmV4cG9ydCBjb25zdCB1c2VTdGlja1RvQm90dG9tID0gKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IFtlc2NhcGVkRnJvbUxvY2ssIHVwZGF0ZUVzY2FwZWRGcm9tTG9ja10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2lzQXRCb3R0b20sIHVwZGF0ZUlzQXRCb3R0b21dID0gdXNlU3RhdGUob3B0aW9ucy5pbml0aWFsICE9PSBmYWxzZSk7XG4gICAgY29uc3QgW2lzTmVhckJvdHRvbSwgc2V0SXNOZWFyQm90dG9tXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBvcHRpb25zUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIG9wdGlvbnNSZWYuY3VycmVudCA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNTZWxlY3RpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICghbW91c2VEb3duKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCAhc2VsZWN0aW9uLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICByZXR1cm4gKHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLmNvbnRhaW5zKHNjcm9sbFJlZi5jdXJyZW50KSB8fFxuICAgICAgICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQ/LmNvbnRhaW5zKHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHNldElzQXRCb3R0b20gPSB1c2VDYWxsYmFjaygoaXNBdEJvdHRvbSkgPT4ge1xuICAgICAgICBzdGF0ZS5pc0F0Qm90dG9tID0gaXNBdEJvdHRvbTtcbiAgICAgICAgdXBkYXRlSXNBdEJvdHRvbShpc0F0Qm90dG9tKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgc2V0RXNjYXBlZEZyb21Mb2NrID0gdXNlQ2FsbGJhY2soKGVzY2FwZWRGcm9tTG9jaykgPT4ge1xuICAgICAgICBzdGF0ZS5lc2NhcGVkRnJvbUxvY2sgPSBlc2NhcGVkRnJvbUxvY2s7XG4gICAgICAgIHVwZGF0ZUVzY2FwZWRGcm9tTG9jayhlc2NhcGVkRnJvbUxvY2spO1xuICAgIH0sIFtdKTtcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiBub3QgbmVlZGVkXG4gICAgY29uc3Qgc3RhdGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IGxhc3RDYWxjdWxhdGlvbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVzY2FwZWRGcm9tTG9jayxcbiAgICAgICAgICAgIGlzQXRCb3R0b20sXG4gICAgICAgICAgICByZXNpemVEaWZmZXJlbmNlOiAwLFxuICAgICAgICAgICAgYWNjdW11bGF0ZWQ6IDAsXG4gICAgICAgICAgICB2ZWxvY2l0eTogMCxcbiAgICAgICAgICAgIGxpc3RlbmVyczogbmV3IFNldCgpLFxuICAgICAgICAgICAgZ2V0IHNjcm9sbFRvcCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsUmVmLmN1cnJlbnQ/LnNjcm9sbFRvcCA/PyAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBzY3JvbGxUb3Aoc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFJlZi5jdXJyZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlU2Nyb2xsVG9Ub3AgPSBzY3JvbGxSZWYuY3VycmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCB0YXJnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzY3JvbGxSZWYuY3VycmVudCB8fCAhY29udGVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKHNjcm9sbFJlZi5jdXJyZW50LnNjcm9sbEhlaWdodCAtIDEgLSBzY3JvbGxSZWYuY3VycmVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjYWxjdWxhdGVkVGFyZ2V0U2Nyb2xsVG9wKCkge1xuICAgICAgICAgICAgICAgIGlmICghc2Nyb2xsUmVmLmN1cnJlbnQgfHwgIWNvbnRlbnRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0YXJnZXRTY3JvbGxUb3AgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRhcmdldFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0U2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFzdENhbGN1bGF0aW9uPy50YXJnZXRTY3JvbGxUb3AgPT09IHRhcmdldFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdENhbGN1bGF0aW9uLmNhbGN1bGF0ZWRTY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRTY3JvbGxUb3AgPSBNYXRoLm1heChNYXRoLm1pbihvcHRpb25zLnRhcmdldFNjcm9sbFRvcCh0YXJnZXRTY3JvbGxUb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRWxlbWVudDogc2Nyb2xsUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50OiBjb250ZW50UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgfSksIHRhcmdldFNjcm9sbFRvcCksIDApO1xuICAgICAgICAgICAgICAgIGxhc3RDYWxjdWxhdGlvbiA9IHsgdGFyZ2V0U2Nyb2xsVG9wLCBjYWxjdWxhdGVkU2Nyb2xsVG9wIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENhbGN1bGF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkU2Nyb2xsVG9wO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBzY3JvbGxEaWZmZXJlbmNlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZWRUYXJnZXRTY3JvbGxUb3AgLSB0aGlzLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaXNOZWFyQm90dG9tKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjcm9sbERpZmZlcmVuY2UgPD0gU1RJQ0tfVE9fQk9UVE9NX09GRlNFVF9QWDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHNjcm9sbFRvQm90dG9tID0gdXNlQ2FsbGJhY2soKHNjcm9sbE9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNjcm9sbE9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHNjcm9sbE9wdGlvbnMgPSB7IGFuaW1hdGlvbjogc2Nyb2xsT3B0aW9ucyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2Nyb2xsT3B0aW9ucy5wcmVzZXJ2ZVNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBzZXRJc0F0Qm90dG9tKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhaXRFbGFwc2VkID0gRGF0ZS5ub3coKSArIChOdW1iZXIoc2Nyb2xsT3B0aW9ucy53YWl0KSB8fCAwKTtcbiAgICAgICAgY29uc3QgYmVoYXZpb3IgPSBtZXJnZUFuaW1hdGlvbnMob3B0aW9uc1JlZi5jdXJyZW50LCBzY3JvbGxPcHRpb25zLmFuaW1hdGlvbik7XG4gICAgICAgIGNvbnN0IHsgaWdub3JlRXNjYXBlcyA9IGZhbHNlIH0gPSBzY3JvbGxPcHRpb25zO1xuICAgICAgICBsZXQgZHVyYXRpb25FbGFwc2VkO1xuICAgICAgICBsZXQgc3RhcnRUYXJnZXQgPSBzdGF0ZS5jYWxjdWxhdGVkVGFyZ2V0U2Nyb2xsVG9wO1xuICAgICAgICBpZiAoc2Nyb2xsT3B0aW9ucy5kdXJhdGlvbiBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHNjcm9sbE9wdGlvbnMuZHVyYXRpb24uZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25FbGFwc2VkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb25FbGFwc2VkID0gd2FpdEVsYXBzZWQgKyAoc2Nyb2xsT3B0aW9ucy5kdXJhdGlvbiA/PyAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlcXVlc3RBbmltYXRpb25GcmFtZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc0F0Qm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCB9ID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGljayA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tEZWx0YSA9ICh0aWNrIC0gKHN0YXRlLmxhc3RUaWNrID8/IHRpY2spKSAvIFNJWFRZX0ZQU19JTlRFUlZBTF9NUztcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbmltYXRpb24gfHwgKHN0YXRlLmFuaW1hdGlvbiA9IHsgYmVoYXZpb3IsIHByb21pc2UsIGlnbm9yZUVzY2FwZXMgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmFuaW1hdGlvbi5iZWhhdmlvciA9PT0gYmVoYXZpb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubGFzdFRpY2sgPSB0aWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTZWxlY3RpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2FpdEVsYXBzZWQgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUb3AgPCBNYXRoLm1pbihzdGFydFRhcmdldCwgc3RhdGUuY2FsY3VsYXRlZFRhcmdldFNjcm9sbFRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmFuaW1hdGlvbj8uYmVoYXZpb3IgPT09IGJlaGF2aW9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVoYXZpb3IgPT09IFwiaW5zdGFudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2Nyb2xsVG9wID0gc3RhdGUuY2FsY3VsYXRlZFRhcmdldFNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudmVsb2NpdHkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChiZWhhdmlvci5kYW1waW5nICogc3RhdGUudmVsb2NpdHkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWhhdmlvci5zdGlmZm5lc3MgKiBzdGF0ZS5zY3JvbGxEaWZmZXJlbmNlKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlaGF2aW9yLm1hc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hY2N1bXVsYXRlZCArPSBzdGF0ZS52ZWxvY2l0eSAqIHRpY2tEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNjcm9sbFRvcCArPSBzdGF0ZS5hY2N1bXVsYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zY3JvbGxUb3AgIT09IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmFjY3VtdWxhdGVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25FbGFwc2VkID4gRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRhcmdldCA9IHN0YXRlLmNhbGN1bGF0ZWRUYXJnZXRTY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmFuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSdyZSBzdGlsbCBiZWxvdyB0aGUgdGFyZ2V0LCB0aGVuIHF1ZXVlXG4gICAgICAgICAgICAgICAgICogdXAgYW5vdGhlciBzY3JvbGwgdG8gdGhlIGJvdHRvbSB3aXRoIHRoZSBsYXN0XG4gICAgICAgICAgICAgICAgICogcmVxdWVzdGVkIGFuaW1hdGluby5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2Nyb2xsVG9wIDwgc3RhdGUuY2FsY3VsYXRlZFRhcmdldFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsVG9Cb3R0b20oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBtZXJnZUFuaW1hdGlvbnMob3B0aW9uc1JlZi5jdXJyZW50LCBvcHRpb25zUmVmLmN1cnJlbnQucmVzaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZUVzY2FwZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5tYXgoMCwgZHVyYXRpb25FbGFwc2VkIC0gRGF0ZS5ub3coKSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmlzQXRCb3R0b207XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKGlzQXRCb3R0b20pID0+IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubGFzdFRpY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNBdEJvdHRvbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc2Nyb2xsT3B0aW9ucy53YWl0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmFuaW1hdGlvbj8uYmVoYXZpb3IgPT09IGJlaGF2aW9yKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuYW5pbWF0aW9uLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9LCBbc2V0SXNBdEJvdHRvbSwgaXNTZWxlY3RpbmcsIHN0YXRlXSk7XG4gICAgY29uc3Qgc3RvcFNjcm9sbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0RXNjYXBlZEZyb21Mb2NrKHRydWUpO1xuICAgICAgICBzZXRJc0F0Qm90dG9tKGZhbHNlKTtcbiAgICB9LCBbc2V0RXNjYXBlZEZyb21Mb2NrLCBzZXRJc0F0Qm90dG9tXSk7XG4gICAgY29uc3QgaGFuZGxlU2Nyb2xsID0gdXNlQ2FsbGJhY2soKHsgdGFyZ2V0IH0pID0+IHtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gc2Nyb2xsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgaWdub3JlU2Nyb2xsVG9Ub3AgfSA9IHN0YXRlO1xuICAgICAgICBsZXQgeyBsYXN0U2Nyb2xsVG9wID0gc2Nyb2xsVG9wIH0gPSBzdGF0ZTtcbiAgICAgICAgc3RhdGUubGFzdFNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgc3RhdGUuaWdub3JlU2Nyb2xsVG9Ub3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpZ25vcmVTY3JvbGxUb1RvcCAmJiBpZ25vcmVTY3JvbGxUb1RvcCA+IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSB1c2VyIHNjcm9sbHMgdXAgd2hpbGUgdGhlIGFuaW1hdGlvbiBwbGF5cywgdGhlIGBzY3JvbGxUb3BgIG1heVxuICAgICAgICAgICAgICogbm90IGNvbWUgaW4gc2VwYXJhdGUgZXZlbnRzOyBpZiB0aGlzIGhhcHBlbnMsIHRvIG1ha2Ugc3VyZSBgaXNTY3JvbGxpbmdVcGBcbiAgICAgICAgICAgICAqIGlzIGNvcnJlY3QsIHNldCB0aGUgbGFzdFNjcm9sbFRvcCB0byB0aGUgaWdub3JlZCBldmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGFzdFNjcm9sbFRvcCA9IGlnbm9yZVNjcm9sbFRvVG9wO1xuICAgICAgICB9XG4gICAgICAgIHNldElzTmVhckJvdHRvbShzdGF0ZS5pc05lYXJCb3R0b20pO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Nyb2xsIGV2ZW50cyBtYXkgY29tZSBiZWZvcmUgYSBSZXNpemVPYnNlcnZlciBldmVudCxcbiAgICAgICAgICogc28gaW4gb3JkZXIgdG8gaWdub3JlIHJlc2l6ZSBldmVudHMgY29ycmVjdGx5IHdlIHVzZSBhXG4gICAgICAgICAqIHRpbWVvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvcmVzaXplLW9ic2VydmVyL2lzc3Vlcy8yNSNpc3N1ZWNvbW1lbnQtMjQ4NzU3MjI4XG4gICAgICAgICAqL1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGVyZXMgYSByZXNpemUgZGlmZmVyZW5jZSBpZ25vcmUgdGhlIHJlc2l6ZSBldmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlc2l6ZURpZmZlcmVuY2UgfHwgc2Nyb2xsVG9wID09PSBpZ25vcmVTY3JvbGxUb1RvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGluZygpKSB7XG4gICAgICAgICAgICAgICAgc2V0RXNjYXBlZEZyb21Mb2NrKHRydWUpO1xuICAgICAgICAgICAgICAgIHNldElzQXRCb3R0b20oZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzU2Nyb2xsaW5nRG93biA9IHNjcm9sbFRvcCA+IGxhc3RTY3JvbGxUb3A7XG4gICAgICAgICAgICBjb25zdCBpc1Njcm9sbGluZ1VwID0gc2Nyb2xsVG9wIDwgbGFzdFNjcm9sbFRvcDtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hbmltYXRpb24/Lmlnbm9yZUVzY2FwZXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zY3JvbGxUb3AgPSBsYXN0U2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Njcm9sbGluZ1VwKSB7XG4gICAgICAgICAgICAgICAgc2V0RXNjYXBlZEZyb21Mb2NrKHRydWUpO1xuICAgICAgICAgICAgICAgIHNldElzQXRCb3R0b20oZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU2Nyb2xsaW5nRG93bikge1xuICAgICAgICAgICAgICAgIHNldEVzY2FwZWRGcm9tTG9jayhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmVzY2FwZWRGcm9tTG9jayAmJiBzdGF0ZS5pc05lYXJCb3R0b20pIHtcbiAgICAgICAgICAgICAgICBzZXRJc0F0Qm90dG9tKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxKTtcbiAgICB9LCBbc2V0RXNjYXBlZEZyb21Mb2NrLCBzZXRJc0F0Qm90dG9tLCBpc1NlbGVjdGluZywgc3RhdGVdKTtcbiAgICBjb25zdCBoYW5kbGVXaGVlbCA9IHVzZUNhbGxiYWNrKCh7IHRhcmdldCwgZGVsdGFZIH0pID0+IHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSB0YXJnZXQ7XG4gICAgICAgIHdoaWxlICghW1wic2Nyb2xsXCIsIFwiYXV0b1wiXS5pbmNsdWRlcyhnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLm92ZXJmbG93KSkge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYnJvd3NlciBtYXkgY2FuY2VsIHRoZSBzY3JvbGxpbmcgZnJvbSB0aGUgbW91c2Ugd2hlZWxcbiAgICAgICAgICogaWYgd2UgdXBkYXRlIGl0IGZyb20gdGhlIGFuaW1hdGlvbiBpbiBtZWFudGltZS5cbiAgICAgICAgICogVG8gcHJldmVudCB0aGlzLCBhbHdheXMgZXNjYXBlIHdoZW4gdGhlIHdoZWVsIGlzIHNjcm9sbGVkIHVwLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNjcm9sbFJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICBkZWx0YVkgPCAwICYmXG4gICAgICAgICAgICBzY3JvbGxSZWYuY3VycmVudC5zY3JvbGxIZWlnaHQgPiBzY3JvbGxSZWYuY3VycmVudC5jbGllbnRIZWlnaHQgJiZcbiAgICAgICAgICAgICFzdGF0ZS5hbmltYXRpb24/Lmlnbm9yZUVzY2FwZXMpIHtcbiAgICAgICAgICAgIHNldEVzY2FwZWRGcm9tTG9jayh0cnVlKTtcbiAgICAgICAgICAgIHNldElzQXRCb3R0b20oZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgW3NldEVzY2FwZWRGcm9tTG9jaywgc2V0SXNBdEJvdHRvbSwgc3RhdGVdKTtcbiAgICBjb25zdCBzY3JvbGxSZWYgPSB1c2VSZWZDYWxsYmFjaygoc2Nyb2xsKSA9PiB7XG4gICAgICAgIHNjcm9sbFJlZi5jdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbCk7XG4gICAgICAgIHNjcm9sbFJlZi5jdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgaGFuZGxlV2hlZWwpO1xuICAgICAgICBzY3JvbGw/LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHNjcm9sbD8uYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIGhhbmRsZVdoZWVsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGNvbnRlbnRSZWYgPSB1c2VSZWZDYWxsYmFjaygoY29udGVudCkgPT4ge1xuICAgICAgICBzdGF0ZS5yZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJldmlvdXNIZWlnaHQ7XG4gICAgICAgIHN0YXRlLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChbZW50cnldKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGhlaWdodCB9ID0gZW50cnkuY29udGVudFJlY3Q7XG4gICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gaGVpZ2h0IC0gKHByZXZpb3VzSGVpZ2h0ID8/IGhlaWdodCk7XG4gICAgICAgICAgICBzdGF0ZS5yZXNpemVEaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU29tZXRpbWVzIHRoZSBicm93c2VyIGNhbiBvdmVyc2Nyb2xsIHBhc3QgdGhlIHRhcmdldCxcbiAgICAgICAgICAgICAqIHNvIGNoZWNrIGZvciB0aGlzIGFuZCBhZGp1c3QgYXBwcm9wcmlhdGVseS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNjcm9sbFRvcCA+IHN0YXRlLnRhcmdldFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnNjcm9sbFRvcCA9IHN0YXRlLnRhcmdldFNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldElzTmVhckJvdHRvbShzdGF0ZS5pc05lYXJCb3R0b20pO1xuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIGl0J3MgYSBwb3NpdGl2ZSByZXNpemUsIHNjcm9sbCB0byB0aGUgYm90dG9tIHdoZW5cbiAgICAgICAgICAgICAgICAgKiB3ZSdyZSBhbHJlYWR5IGF0IHRoZSBib3R0b20uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gbWVyZ2VBbmltYXRpb25zKG9wdGlvbnNSZWYuY3VycmVudCwgcHJldmlvdXNIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zUmVmLmN1cnJlbnQucmVzaXplXG4gICAgICAgICAgICAgICAgICAgIDogb3B0aW9uc1JlZi5jdXJyZW50LmluaXRpYWwpO1xuICAgICAgICAgICAgICAgIHNjcm9sbFRvQm90dG9tKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICB3YWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVNjcm9sbFBvc2l0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uID09PSBcImluc3RhbnRcIiA/IHVuZGVmaW5lZCA6IFJFVEFJTl9BTklNQVRJT05fRFVSQVRJT05fTVMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbHNlIGlmIGl0J3MgYSBuZWdhdGl2ZSByZXNpemUsIGNoZWNrIGlmIHdlJ3JlIG5lYXIgdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAqIGlmIHdlIGFyZSB3YW50IHRvIHVuLWVzY2FwZSBmcm9tIHRoZSBsb2NrLCBiZWNhdXNlIHRoZSByZXNpemVcbiAgICAgICAgICAgICAgICAgKiBjb3VsZCBoYXZlIGNhdXNlZCB0aGUgY29udGFpbmVyIHRvIGJlIGF0IHRoZSBib3R0b20uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzTmVhckJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRFc2NhcGVkRnJvbUxvY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzZXRJc0F0Qm90dG9tKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXNldCB0aGUgcmVzaXplIGRpZmZlcmVuY2UgYWZ0ZXIgdGhlIHNjcm9sbCBldmVudFxuICAgICAgICAgICAgICogaGFzIGZpcmVkLiBSZXF1aXJlcyBhIHJBRiB0byB3YWl0IGZvciB0aGUgc2Nyb2xsIGV2ZW50LFxuICAgICAgICAgICAgICogYW5kIGEgc2V0VGltZW91dCB0byB3YWl0IGZvciB0aGUgb3RoZXIgdGltZW91dCB3ZSBoYXZlIGluXG4gICAgICAgICAgICAgKiByZXNpemVPYnNlcnZlciBpbiBjYXNlIHRoZSBzY3JvbGwgZXZlbnQgaGFwcGVucyBhZnRlciB0aGVcbiAgICAgICAgICAgICAqIHJlc2l6ZSBldmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnJlc2l6ZURpZmZlcmVuY2UgPT09IGRpZmZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnJlc2l6ZURpZmZlcmVuY2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLnJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKGNvbnRlbnQpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50UmVmLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHNjcm9sbFRvQm90dG9tLFxuICAgICAgICBzdG9wU2Nyb2xsLFxuICAgICAgICBpc0F0Qm90dG9tOiBpc0F0Qm90dG9tIHx8IGlzTmVhckJvdHRvbSxcbiAgICAgICAgaXNOZWFyQm90dG9tLFxuICAgICAgICBlc2NhcGVkRnJvbUxvY2ssXG4gICAgICAgIHN0YXRlLFxuICAgIH07XG59O1xuZnVuY3Rpb24gdXNlUmVmQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiBub3QgbmVlZGVkXG4gICAgY29uc3QgcmVzdWx0ID0gdXNlQ2FsbGJhY2soKHJlZikgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudCA9IHJlZjtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlZik7XG4gICAgfSwgZGVwcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGFuaW1hdGlvbkNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gbWVyZ2VBbmltYXRpb25zKC4uLmFuaW1hdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLkRFRkFVTFRfU1BSSU5HX0FOSU1BVElPTiB9O1xuICAgIGxldCBpbnN0YW50ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBhbmltYXRpb24gb2YgYW5pbWF0aW9ucykge1xuICAgICAgICBpZiAoYW5pbWF0aW9uID09PSBcImluc3RhbnRcIikge1xuICAgICAgICAgICAgaW5zdGFudCA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFuaW1hdGlvbiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFudCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQuZGFtcGluZyA9IGFuaW1hdGlvbi5kYW1waW5nID8/IHJlc3VsdC5kYW1waW5nO1xuICAgICAgICByZXN1bHQuc3RpZmZuZXNzID0gYW5pbWF0aW9uLnN0aWZmbmVzcyA/PyByZXN1bHQuc3RpZmZuZXNzO1xuICAgICAgICByZXN1bHQubWFzcyA9IGFuaW1hdGlvbi5tYXNzID8/IHJlc3VsdC5tYXNzO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgIGlmICghYW5pbWF0aW9uQ2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgYW5pbWF0aW9uQ2FjaGUuc2V0KGtleSwgT2JqZWN0LmZyZWV6ZShyZXN1bHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbnQgPyBcImluc3RhbnRcIiA6IGFuaW1hdGlvbkNhY2hlLmdldChrZXkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-stick-to-bottom/dist/useStickToBottom.js\n");

/***/ })

};
;